local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local Window = WindUI:CreateWindow({
    Folder = "Darkz Hub",
    Title = "Darkz Hub",
    Icon = "star",
    Author = "RINGTA and BUBLIK6241",
    Theme = "Dark",
    Size = UDim2.fromOffset(500, 420),
    HasOutline = true,
})

----------------------------------------------------------------
-- STAMINA TAB
----------------------------------------------------------------
local StaminaTab = Window:Tab({
    Title = "STAMINA",
    Icon = "footprints",
    Locked = false,
})

local sprintModule = require(ReplicatedStorage.Systems.Character.Game.Sprinting)

local defaultMaxStamina = sprintModule.MaxStamina
local defaultSprintSpeed = sprintModule.SprintSpeed
local defaultStaminaGain = sprintModule.StaminaGain
local defaultStaminaDrain = sprintModule.StaminaDrain or 1
local defaultRegenDelay = sprintModule.StaminaRegenDelay or 0.5

_G.InfStamina = false

StaminaTab:Toggle({
    Title = "Infinite Stamina",
    Desc = "Infinite stamina",
    Icon = "bird",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        _G.InfStamina = state
    end
})

StaminaTab:Slider({
    Title = "Max Stamina",
    Step = 1,
    Value = { Min = 20, Max = 12000, Default = defaultMaxStamina },
    Callback = function(v)
        sprintModule.MaxStamina = v
        sprintModule.Stamina = math.min(sprintModule.Stamina, v)
    end
})

StaminaTab:Slider({
    Title = "Sprint Speed",
    Step = 1,
    Value = { Min = 10, Max = 500, Default = defaultSprintSpeed },
    Callback = function(v)
        sprintModule.SprintSpeed = v
    end
})

StaminaTab:Slider({
    Title = "Stamina Drain",
    Step = 1,
    Value = { Min = 0, Max = 100, Default = defaultStaminaDrain },
    Callback = function(v)
        sprintModule.StaminaDrain = v
    end
})

StaminaTab:Slider({
    Title = "Stamina Gain",
    Step = 1,
    Value = { Min = 0, Max = 200, Default = defaultStaminaGain },
    Callback = function(v)
        sprintModule.StaminaGain = v
    end
})

StaminaTab:Slider({
    Title = "Regen Delay",
    Step = 0.1,
    Value = { Min = 0, Max = 10, Default = defaultRegenDelay },
    Callback = function(v)
        sprintModule.StaminaRegenDelay = v
    end
})

StaminaTab:Button({
    Title = "Reset Stamina",
    Callback = function()
        sprintModule.MaxStamina = defaultMaxStamina
        sprintModule.SprintSpeed = defaultSprintSpeed
        sprintModule.StaminaGain = defaultStaminaGain
        sprintModule.StaminaDrain = defaultStaminaDrain
        sprintModule.StaminaRegenDelay = defaultRegenDelay
    end
})

task.spawn(function()
    while task.wait() do
        if _G.InfStamina then
            sprintModule.Stamina = sprintModule.MaxStamina
        end
    end
end)

----------------------------------------------------------------
-- ESP TAB
----------------------------------------------------------------
local EspTab = Window:Tab({
    Title = "ESP",
    Icon = "eye",
    Locked = false,
})

local function makeHighlight(model, color)
    local h = Instance.new("Highlight")
    h.FillColor = color
    h.OutlineColor = color
    h.FillTransparency = 0.6
    h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    h.Adornee = model
    h.Parent = model
    return h
end

local killerESP, survivorESP = false, false
local killerHL, survivorHL = {}, {}

local function clear(tbl)
    for _, h in ipairs(tbl) do
        if h then h:Destroy() end
    end
    table.clear(tbl)
end

EspTab:Toggle({
    Title = "ESP Killers",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        killerESP = state
        clear(killerHL)
        if state then
            for _, k in ipairs((Workspace.Players:FindFirstChild("Killers") or {}):GetChildren()) do
                table.insert(killerHL, makeHighlight(k, Color3.fromRGB(255,0,0)))
            end
        end
    end
})

EspTab:Toggle({
    Title = "ESP Survivors",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        survivorESP = state
        clear(survivorHL)
        if state then
            for _, s in ipairs((Workspace.Players:FindFirstChild("Survivors") or {}):GetChildren()) do
                table.insert(survivorHL, makeHighlight(s, Color3.fromRGB(0,255,0)))
            end
        end
    end
})

local medkitESP, bloxyESP = false, false

local function itemESP(name, color, enabled)
    for _, i in ipairs(Workspace:GetDescendants()) do
        if i.Name == name and i:IsA("Model") then
            if enabled then
                if not i:FindFirstChild("ItemHL") then
                    local h = Instance.new("Highlight")
                    h.Name = "ItemHL"
                    h.FillColor = color
                    h.OutlineColor = color
                    h.Adornee = i
                    h.Parent = i
                end
            else
                local h = i:FindFirstChild("ItemHL")
                if h then h:Destroy() end
            end
        end
    end
end

EspTab:Toggle({
    Title = "ESP Medkit",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        medkitESP = state
        itemESP("Medkit", Color3.fromRGB(255,105,180), state)
    end
})

EspTab:Toggle({
    Title = "ESP Bloxy Cola",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        bloxyESP = state
        itemESP("BloxyCola", Color3.fromRGB(0,150,255), state)
    end
})

local espGeneratorsActive = false
local generatorHighlights = {}
local generatorEspThread

local function clearGeneratorHighlights()
    for _, h in ipairs(generatorHighlights) do
        if h and h.Parent then h:Destroy() end
    end
    generatorHighlights = {}
end

local function createGeneratorHighlight(target)
    local highlight = Instance.new("Highlight")
    highlight.Adornee = target
    highlight.FillColor = Color3.fromRGB(255, 255, 255)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.6
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = target
    table.insert(generatorHighlights, highlight)
end

local function updateGeneratorESP()
    clearGeneratorHighlights()
    -- Ð Â˜Ð¡â€°Ð ÂµÐ Ñ˜ Ð Ð†Ð Ñ• Ð Ð†Ð¡ÐƒÐ ÂµÐ â„– Ð Ñ‘Ð Ñ–Ð¡Ð‚Ð Ñ•Ð Ð†Ð Ñ•Ð â„– Ð Ñ•Ð Â±Ð Â»Ð Â°Ð¡ÐƒÐ¡â€šÐ Ñ‘, Ð Â° Ð Ð…Ð Âµ Ð Ñ—Ð Ñ• Ð Ñ”Ð Ñ•Ð Ð…Ð Ñ”Ð¡Ð‚Ð ÂµÐ¡â€šÐ Ð…Ð Ñ•Ð Ñ˜Ð¡Ñ“ Ð Ñ—Ð¡Ñ“Ð¡â€šÐ Ñ‘
    for _, item in ipairs(Workspace:GetDescendants()) do
        -- Ð Â˜Ð¡ÐƒÐ Ñ—Ð Ñ•Ð Â»Ð¡ÐŠÐ Â·Ð¡Ñ“Ð ÂµÐ Ñ˜ string.find Ð Ò‘Ð Â»Ð¡Ð Ð Ñ—Ð Ñ•Ð Ñ‘Ð¡ÐƒÐ Ñ”Ð Â° Ð Ñ—Ð Ñ• Ð¡â€¡Ð Â°Ð¡ÐƒÐ¡â€šÐ Ñ‘ Ð Ñ‘Ð Ñ˜Ð ÂµÐ Ð…Ð Ñ‘
        if item.Name:find("Generator") then
            if (item:IsA("Model") and item.PrimaryPart) or item:IsA("BasePart") then
                createGeneratorHighlight(item)
            end
        end
    end
end

local Toggle = Tab:Toggle({
    Title = "Esp Generator",
    Desc = "Esp those",
    Icon = "bell",
    Type = "Checkbox",
    Value = false, -- default value
    Callback = function(state) 
        espGeneratorsActive = state
        if espGeneratorsActive then
            generatorEspThread = task.spawn(function()
                while espGeneratorsActive do
                    updateGeneratorESP()
                    task.wait(20)
                end
            end)
        else
            if generatorEspThread then task.cancel(generatorEspThread); generatorEspThread = nil end
            clearGeneratorHighlights()
        end
    end
    end
})


local Tab = Window:Tab({
    Title = "Auto Block",
    Icon = "shield", -- optional
    Locked = false,
})

local autoBlockOn = false
local detectionRange = 18
local looseFacing = true
local strictRangeOn = true
local windupThreshold = 0.75 -- Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ 75%

local autoBlockTriggerAnims = {
    "126830014841198", "126355327951215", "121086746534252", "18885909645",
    "98456918873918", "105458270463374", "83829782357897", "125403313786645",
    "118298475669935", "82113744478546", "70371667919898", "99135633258223",
    "97167027849946", "109230267448394", "139835501033932", "126896426760253",
    "109667959938617", "126681776859538", "129976080405072", "121293883585738",
    "81639435858902", "137314737492715",
    "92173139187970"
}

local function isFacing(localRoot, targetRoot)
    local dir = (localRoot.Position - targetRoot.Position).Unit
    local dot = targetRoot.CFrame.LookVector:Dot(dir)
    return looseFacing and dot > -0.3 or dot > 0
end

local function fireRemoteBlock()
    local args = {
        "UseActorAbility",
        {
            buffer.fromstring("\"Block\"")
        }
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
end

local blockConnection = nil

local function startAutoBlock()
    blockConnection = RunService.Heartbeat:Connect(function()
        local myChar = LocalPlayer.Character
        if not myChar then return end
        local myRoot = myChar:FindFirstChild("HumanoidRootPart")
        local humanoid = myChar:FindFirstChildOfClass("Humanoid")
        if not myRoot or not humanoid then return end

        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character then
                local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
                local hum = plr.Character:FindFirstChildOfClass("Humanoid")
                local animTracks = hum and hum:FindFirstChildOfClass("Animator") and hum:FindFirstChildOfClass("Animator"):GetPlayingAnimationTracks()
                if hrp and (hrp.Position - myRoot.Position).Magnitude <= detectionRange then
                    for _, track in ipairs(animTracks or {}) do
                        local id = tostring(track.Animation.AnimationId):match("%d+")
                        if table.find(autoBlockTriggerAnims, id) then
                            local progress = track.TimePosition / track.Length
                            if progress < windupThreshold then -- Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð¿Ñ€Ð¾Ñ†ÐµÐ½Ñ‚Ð° Windup
                                if autoBlockOn and (not strictRangeOn or (hrp.Position - myRoot.Position).Magnitude <= detectionRange) then
                                    if isFacing(myRoot, hrp) then
                                        fireRemoteBlock()
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
end

local function stopAutoBlock()
    if blockConnection then
        blockConnection:Disconnect()
        blockConnection = nil
    end
end

local Toggle = Tab:Toggle({
    Title = "Auto Block (animation)",
    Desc = "Auto",
    Icon = "shield",
    Type = "Checkbox",
    Value = false, -- default value
    Callback = function(state) 
        autoBlockOn = state
        if state then
            startAutoBlock()
            WindUI:Notify({ Title = "Auto Block", Content = "Enabled!", Duration = 1 })
        else
            stopAutoBlock()
            WindUI:Notify({ Title = "Auto Block", Content = "Disabled!", Duration = 1 })
        end
    end
    end
})

local Slider = Tab:Slider({
    Title = "Detection Range(Animation)",
    Step = 1,
    Value = {Min = 1, Max = 50, Default = detectionRange},
    Suffix = " studs",
    Callback = function(val)
        detectionRange = tonumber(val) or detectionRange
    end
})

local Slider = Tab:Slider({
    Title = "Windup %",
    Step = 5,
    Value = {Min = 1, Max = 100, Default = 75},
    Suffix = "%",
    Callback = function(val)
        windupThreshold = (tonumber(val) or 75) / 100
    end
})

local Button = Tab:Button({
    Title = "Auto Block Audio load",
    Desc = "load that shi",
    Locked = false,
    Callback = function()
local Players = game:GetService("Players")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RunService = game:GetService("RunService")

        local lp = Players.LocalPlayer

        -- Ð¡Ð¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ
        local autoBlockAudioOn = false
        local detectionRange = 20
        local detectionRangeSq = detectionRange * detectionRange
        local cachedCooldown = nil
        local currentMode = "Normal"
        local zoneVisibility = 0.4 
        local runZoneBoost = 4     
        local zoneLength = 12      
        local zoneWidth = 6        
        
        --- ÐÐžÐ’ÐžÐ•: Ð”Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ Ð¾Ñ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸Ñ Ð°Ñ‚Ð°ÐºÐ¸ Ð² ÑÐµÐºÑƒÐ½Ð´Ð°Ñ… ---
        local monitorDuration = 0.6 -- Ð‘ÑƒÐ´ÐµÐ¼ Ð¾Ñ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ñ‚ÑŒ Ð°Ñ‚Ð°ÐºÑƒ Ð² Ñ‚ÐµÑ‡ÐµÐ½Ð¸Ðµ 0.6 ÑÐµÐºÑƒÐ½Ð´Ñ‹ Ð¿Ð¾ÑÐ»Ðµ Ð½Ð°Ñ‡Ð°Ð»Ð° Ð·Ð²ÑƒÐºÐ°

        --- ÐÐžÐ’ÐžÐ•: Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð´Ð»Ñ Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ñ… Ð°Ñ‚Ð°Ðº, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð½ÑƒÐ¶Ð½Ð¾ Ð¾Ñ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ñ‚ÑŒ ---
        local activeAttacks = {}

        -- Ð¡Ð¿Ð¸ÑÐ¾Ðº ID Ð·Ð²ÑƒÐºÐ¾Ð² (Ð°Ñ‚Ð°ÐºÐ¸)
        local autoBlockTriggerSounds = {
            ["102228729296384"] = true, ["140242176732868"] = true, ["112809109188560"] = true,
            ["136323728355613"] = true, ["115026634746636"] = true, ["84116622032112"] = true,
            ["108907358619313"] = true, ["127793641088496"] = true, ["86174610237192"] = true,
            ["95079963655241"] = true, ["101199185291628"] = true, ["119942598489800"] = true,
            ["84307400688050"] = true, ["113037804008732"] = true, ["105200830849301"] = true,
            ["75330693422988"] = true, ["82221759983649"] = true, ["81702359653578"] = true,
            ["108610718831698"] = true, ["112395455254818"] = true, ["109431876587852"] = true,
            ["109348678063422"] = true, ["85853080745515"] = true, ["12222216"] = true
        }

        local soundHooks = {}

        -- Ð¥ÐµÐ»Ð¿ÐµÑ€ Ð´Ð»Ñ Ð±Ð»Ð¾ÐºÐ° (ÐÐžÐ’Ð«Ð™ RemoteEvent Ð²Ñ‹Ð·Ð¾Ð²)
        local function fireRemoteBlock()
            local args = {
                "UseActorAbility",
                {
                    buffer.fromstring("\"Block\"")
                }
            }
            ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
        end

        local function isFacing(localRoot, targetRoot)
            local dir = (localRoot.Position - targetRoot.Position).Unit
            local dot = targetRoot.CFrame.LookVector:Dot(dir)
            return dot > -0.3
        end

        local function extractNumericSoundId(sound)
            if not sound or not sound.SoundId then return nil end
            return tostring(sound.SoundId):match("%d+")
        end

        local function getCharacterFromDescendant(inst)
            if not inst then return nil end
            local model = inst:FindFirstAncestorOfClass("Model")
            if model and model:FindFirstChildOfClass("Humanoid") then return model end
            return nil
        end
        
        local function refreshUIRefs()
            local playerGui = lp:FindFirstChild("PlayerGui")
            if not playerGui then return end
            local main = playerGui:FindFirstChild("MainUI")
            if main then
                local ability = main:FindFirstChild("AbilityContainer")
                local blockBtn = ability and ability:FindFirstChild("Block")
                cachedCooldown = blockBtn and blockBtn:FindFirstChild("CooldownTime")
            else
                cachedCooldown = nil
            end
        end

        -- === Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð·Ð¾Ð½Ñ‹ (Ð´Ð»Ñ Anti Bait) ===
        local function createZoneForKiller(killer)
            if not killer:FindFirstChild("HumanoidRootPart") then return end
            if killer:FindFirstChild("BlockZone") then return end

            local hrp = killer.HumanoidRootPart
            local zone = Instance.new("Part")
            zone.Name = "BlockZone"
            zone.Anchored = false
            zone.CanCollide = false
            zone.Size = Vector3.new(zoneWidth, 7, zoneLength)
            zone.CFrame = hrp.CFrame * CFrame.new(0, 0, -4)
            zone.BrickColor = BrickColor.new("Royal purple")
            zone.Transparency = 1
            zone.Parent = killer

            local weld = Instance.new("WeldConstraint")
            weld.Part0 = hrp
            weld.Part1 = zone
            weld.Parent = zone

            local highlight = Instance.new("Highlight")
            highlight.Name = "ZoneHighlight"
            highlight.Adornee = zone
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.FillColor = Color3.fromRGB(180, 0, 255)
            highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
            highlight.Enabled = false
            highlight.Parent = zone
        end

        -- === Ð”Ð¸Ð½Ð°Ð¼Ð¸Ñ‡ÐµÑÐºÐ¾Ðµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ñ€Ð°Ð·Ð¼ÐµÑ€Ð° Ð·Ð¾Ð½Ñ‹ ===
        local function updateZoneSize(killer)
            local zone = killer:FindFirstChild("BlockZone")
            local hum = killer:FindFirstChildOfClass("Humanoid")
            
            if zone and hum then
                local baseSize = Vector3.new(zoneWidth, 7, zoneLength)
                if hum.MoveDirection.Magnitude > 0.1 then
                    zone.Size = Vector3.new(baseSize.X, baseSize.Y, baseSize.Z + runZoneBoost)
                else
                    zone.Size = baseSize
                end
            end
        end

        -- === Ð›Ð¾Ð³Ð¸ÐºÐ° Ð±Ð»Ð¾ÐºÐ° (Ñ Ð¼Ð¾Ð½Ð¸Ñ‚Ð¾Ñ€Ð¸Ð½Ð³Ð¾Ð¼) ===

        local function registerAttackForMonitoring(sound)
            if not autoBlockAudioOn or not sound or not sound:IsA("Sound") or not sound.IsPlaying then return end
            if activeAttacks[sound] then return end

            local id = extractNumericSoundId(sound)
            if not id or not autoBlockTriggerSounds[id] then return end

            local myChar = lp.Character
            local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if not myRoot then return end

            local soundPart = sound.Parent
            if not (soundPart and soundPart.Parent) then return end
            
            local char = getCharacterFromDescendant(soundPart)
            local plr = char and Players:GetPlayerFromCharacter(char)
            if not plr or plr == lp then return end

            local hrp = char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local dvec = hrp.Position - myRoot.Position
            if dvec:Dot(dvec) > detectionRangeSq then return end
            
            activeAttacks[sound] = {
                killer = char,
                endTime = tick() + monitorDuration
            }
        end

        local function monitorActiveAttacks()
            if not autoBlockAudioOn or next(activeAttacks) == nil then return end

            local myChar = lp.Character
            local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if not myRoot then return end
            
            if cachedCooldown and cachedCooldown.Text ~= "" then
                activeAttacks = {}
                return
            end

            local t = tick()

            for sound, attackData in pairs(activeAttacks) do
                if not sound or sound.Parent == nil or t > attackData.endTime then
                    activeAttacks[sound] = nil
                    continue
                end
                
                local killerChar = attackData.killer
                if not killerChar or killerChar.Parent == nil then
                    activeAttacks[sound] = nil
                    continue
                end

                local killerRoot = killerChar:FindFirstChild("HumanoidRootPart")
                local killerZone = killerChar:FindFirstChild("BlockZone")
                if not killerRoot then
                    activeAttacks[sound] = nil
                    continue
                end

                if isFacing(myRoot, killerRoot) then
                    if currentMode == "Normal" then
                        fireRemoteBlock()
                        activeAttacks = {}
                        break
                    elseif currentMode == "Normal+Anti Bait" and killerZone then
                        local touchingZone = (myRoot.Position - killerZone.Position).Magnitude <= (killerZone.Size.Magnitude / 2 + 2)
                        if touchingZone then
                            fireRemoteBlock()
                            activeAttacks = {}
                            break
                        end
                    end
                end
            end
        end

        local function hookSound(sound)
            if not sound or not sound:IsA("Sound") or soundHooks[sound] then return end

            local playedConn = sound.Played:Connect(function() pcall(registerAttackForMonitoring, sound) end)
            local propConn = sound:GetPropertyChangedSignal("IsPlaying"):Connect(function()
                if sound.IsPlaying then pcall(registerAttackForMonitoring, sound) end
            end)
            
            local destroyConn
            destroyConn = sound.Destroying:Connect(function()
                if playedConn and playedConn.Connected then playedConn:Disconnect() end
                if propConn and propConn.Connected then propConn:Disconnect() end
                if destroyConn and destroyConn.Connected then destroyConn:Disconnect() end
                soundHooks[sound] = nil
                activeAttacks[sound] = nil
            end)

            soundHooks[sound] = {playedConn, propConn, destroyConn}

            if sound.IsPlaying then
                task.spawn(function() pcall(registerAttackForMonitoring, sound) end)
            end
        end
        
        local function updateZonesVisibility()
            local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
            for _, killer in ipairs(killersFolder:GetChildren()) do
                local zone = killer:FindFirstChild("BlockZone")
                if zone then
                    local hl = zone:FindFirstChild("ZoneHighlight")
                    if currentMode == "Normal" then
                        zone.Transparency = 1
                        if hl then hl.Enabled = false end
                    elseif currentMode == "Normal+Anti Bait" then
                        zone.Transparency = zoneVisibility
                        if hl then hl.Enabled = true end
                    end
                end
            end
        end

        task.spawn(function()
            while task.wait(5) do
                if not autoBlockAudioOn then continue end
                local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
                for _, killer in ipairs(killersFolder:GetChildren()) do
                    createZoneForKiller(killer)
                end
                updateZonesVisibility()
            end
        end)

        RunService.Heartbeat:Connect(function()
            if not autoBlockAudioOn then return end
            local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
            for _, killer in ipairs(killersFolder:GetChildren()) do
                updateZoneSize(killer)
            end
            monitorActiveAttacks()
        end)

        lp.CharacterAdded:Connect(function()
            task.delay(0.5, refreshUIRefs)
        end)
        refreshUIRefs()

        for _, desc in ipairs(game:GetDescendants()) do
            if desc:IsA("Sound") then pcall(hookSound, desc) end
        end
        game.DescendantAdded:Connect(function(desc)
            if desc:IsA("Sound") then pcall(hookSound, desc) end
        end)
    end
})

local Toggle = Tab:Toggle({
    Title = "Autoblock audio",
    Desc = "Toggle",
    Icon = "bird",
    Type = "Checkbox",
    Value = false, -- default value
    Callback = function(state) 
                       autoBlockAudioOn = state
            end
    end
})

local Slider = Tab:Slider({
            Title = "Detection Range (Audio)",
            Step = 1,
            Value = {Min = 1, Max = 100, Default = detectionRange},
            Suffix = " studs",
            Callback = function(val)
                detectionRange = val
                detectionRangeSq = val * val
            end
        })
        
          local Dropdown = Tab:Dropdown({
            Title = "Auto Block Mode",
            Values = {"Normal", "Normal+Anti Bait"},
            Value = "Normal",
            Multi = false,
            AllowNone = false,
            Callback = function(choice)
                currentMode = choice
                updateZonesVisibility()
            end
        })
        
        local Slider = Tab:Slider({
            Title = "Attack verification duration",
            Step = 0.1,
            Value = {Min = 0.1, Max = 2.0, Default = 0.6},
            Suffix = " sec",
            Callback = function(val)
                monitorDuration = val
            end
        })
        
        local Slider = Tab:Slider({
            Title = "Zone Visibility",
            Step = 1,
            Value = {Min = 0, Max = 10, Default = 6},
            Suffix = " /10",
            Callback = function(val)
                zoneVisibility = 1 - (val / 10)
                updateZonesVisibility()
            end
        })

        local Slider = Tab:Slider({
            Title = "Zone Length",
            Step = 0.1,
            Value = {Min = 1, Max = 30, Default = 12},
            Suffix = " studs",
            Callback = function(val)
                zoneLength = val
            end
        })

        local Slider = Tab:Slider({
            Title = "Zone Width",
            Step = 0.1,
            Value = {Min = 1, Max = 15, Default = 6},
            Suffix = " studs",
            Callback = function(val)
                zoneWidth = val
            end
        })

        local Slider = Tab:Slider({
            Title = "Zone Boost(if Killer has ping or you have much)",
            Step = 1,
            Value = {Min = 0, Max = 10, Default = 4},
            Suffix = " studs",
            Callback = function(val)
                runZoneBoost = val
            end
        })
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer

local autoPunchOn = false
local flingPunchOn = false
local flingPower = 5000000
local aimPunch = true -- Ð²ÐºÐ»ÑŽÑ‡Ð¸ Ð¿Ñ€ÐµÐ´Ð¸ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ð¹ Ð¿Ð¾Ð²Ð¾Ñ€Ð¾Ñ‚
local hiddenfling = false

local punchConnection = nil
local flingConnection = nil

-- === FLING LOOP ===
local function startFlingLoop()
    if flingConnection then return end
    flingConnection = RunService.Heartbeat:Connect(function()
        if hiddenfling then
            local char = LocalPlayer.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if hrp then
                local vel = hrp.Velocity
                hrp.Velocity = vel * flingPower + Vector3.new(0, flingPower, 0)
                task.wait()
                hrp.Velocity = vel
                task.wait()
                hrp.Velocity = vel + Vector3.new(0, 0.1, 0)
            end
        end
    end)
end

local function stopFlingLoop()
    if flingConnection then
        flingConnection:Disconnect()
        flingConnection = nil
    end
end

-- fling Ñ†Ð¸ÐºÐ»: 3 ÑÐµÐº Ð²ÐºÐ», 1 ÑÐµÐº Ð²Ñ‹ÐºÐ»
local function punchFlingCycle()
    task.spawn(function()
        while flingPunchOn do
            hiddenfling = true
            task.wait(3)
            hiddenfling = false
            task.wait(1)
        end
    end)
end

-- === Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð¿Ñ€ÐµÐ´ÑÐºÐ°Ð·Ð°Ð½Ð¸Ñ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸ ===
local function predictPosition(targetRoot, myPing)
    local velocity = targetRoot.Velocity
    local latency = myPing / 1000 -- Ð¿ÐµÑ€ÐµÐ²Ð¾Ð´ Ð¼Ñ Ð² ÑÐµÐº
    local lookVec = targetRoot.CFrame.LookVector * 5 -- Ð²Ð»Ð¸ÑÐ½Ð¸Ðµ Ð½Ð°Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ñ (5 â€“ Ð¼Ð½Ð¾Ð¶Ð¸Ñ‚ÐµÐ»ÑŒ)
    local predicted = targetRoot.Position + (velocity * latency) + lookVec
    return predicted
end

-- === AUTO PUNCH ===
local function startAutoPunch()
    startFlingLoop()
    if flingPunchOn then
        punchFlingCycle()
    end

    punchConnection = RunService.Heartbeat:Connect(function()
        local myChar = LocalPlayer.Character
        if not myChar then return end
        local myRoot = myChar:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end

        local gui = LocalPlayer:FindFirstChild("PlayerGui"):FindFirstChild("MainUI")
        local punchBtn = gui and gui:FindFirstChild("AbilityContainer") and gui.AbilityContainer:FindFirstChild("Punch")
        local charges = punchBtn and punchBtn:FindFirstChild("Charges")

        if not (punchBtn and charges and charges.Text == "1") then return end

        -- === Ð¡Ð½Ð°Ñ‡Ð°Ð»Ð° Killers ===
        local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
        if killersFolder then
            for _, killer in ipairs(killersFolder:GetChildren()) do
                local root = killer:FindFirstChild("HumanoidRootPart")
                if root and (root.Position - myRoot.Position).Magnitude <= 12 then
                    if aimPunch then
                        local ping = math.max(LocalPlayer:GetNetworkPing() * 1000, 50) -- Ð² Ð¼Ñ
                        local predictedPos = predictPosition(root, ping)

                        -- Ð¼Ð¾Ð¼ÐµÐ½Ñ‚Ð°Ð»ÑŒÐ½Ð¾ Ð¿Ð¾Ð²Ð¾Ñ€Ð°Ñ‡Ð¸Ð²Ð°ÐµÐ¼ Ð¸Ð³Ñ€Ð¾ÐºÐ°
                        myRoot.CFrame = CFrame.lookAt(myRoot.Position, predictedPos)
                        task.delay(1, function()
                            if myChar and myChar:FindFirstChild("HumanoidRootPart") then
                                local forward = myRoot.CFrame.LookVector
                                myRoot.CFrame = CFrame.lookAt(myRoot.Position, myRoot.Position + forward)
                            end
                        end)
                    end

                    for _, conn in ipairs(getconnections(punchBtn.MouseButton1Click)) do
                        pcall(function() conn:Fire() end)
                    end
                    return -- ÑƒÐ´Ð°Ñ€Ð¸Ð»Ð¸ Killers, Ð²Ñ‹Ñ…Ð¾Ð´Ð¸Ð¼
                end
            end
        end

        -- === Ð•ÑÐ»Ð¸ Killers Ð½ÐµÑ‚, Ð¸Ñ‰ÐµÐ¼ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² ===
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local root = player.Character:FindFirstChild("HumanoidRootPart")
                if root and (root.Position - myRoot.Position).Magnitude <= 10 then
                    if aimPunch then
                        local ping = math.max(LocalPlayer:GetNetworkPing() * 1000, 50)
                        local predictedPos = predictPosition(root, ping)

                        myRoot.CFrame = CFrame.lookAt(myRoot.Position, predictedPos)
                        task.delay(1, function()
                            if myChar and myChar:FindFirstChild("HumanoidRootPart") then
                                local forward = myRoot.CFrame.LookVector
                                myRoot.CFrame = CFrame.lookAt(myRoot.Position, myRoot.Position + forward)
                            end
                        end)
                    end

                    for _, conn in ipairs(getconnections(punchBtn.MouseButton1Click)) do
                        pcall(function() conn:Fire() end)
                    end
                    break
                end
            end
        end
    end)
end

local function stopAutoPunch()
    if punchConnection then
        punchConnection:Disconnect()
        punchConnection = nil
    end
    stopFlingLoop()
    hiddenfling = false
end

-- === Toggle ===
local Toggle = Tab:Toggle({
    Title = "Auto Punch+fling(doesn't work when shiwtlock)",
    Default = false,
    Callback = function(state)
        autoPunchOn = state
        if state then
            startAutoPunch()
        else
            stopAutoPunch()
        end
    end
})

-- === Slider Ð´Ð»Ñ flingPower ===
local Toggle = Tab:Slider({
    Title = "Fling Power",
    Step = 100000,
    Value = {Min = 100000, Max = 20000000, Default = flingPower},
    Suffix = " power",
    Callback = function(val)
        flingPower = tonumber(val)
    end
})

-- Block TP
local blockTPEnabled = false
local lastBlockTpTime = 0

-- Toggle
local Toggle = Tab:Toggle({
    Title = "Block TP",
    Default = false,
    Callback = function(state)
        blockTPEnabled = state
    end
})

RunService.RenderStepped:Connect(function()
    if blockTPEnabled and Humanoid and tick() - lastBlockTpTime >= 5 then
        for _, track in ipairs(Humanoid:GetPlayingAnimationTracks()) do
            local animId = tostring(track.Animation.AnimationId):match("%d+")
            if animId == "72722244508749" or animId == "96959123077498" then
                local myRoot = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
                if myRoot then
                    local killers = {"c00lkidd", "Jason", "JohnDoe", "1x1x1x1", "Noli", "Slasher"}
                    for _, name in ipairs(killers) do
                        local killer = workspace:FindFirstChild("Players")
                            and workspace.Players:FindFirstChild("Killers")
                            and workspace.Players.Killers:FindFirstChild(name)

                        if killer and killer:FindFirstChild("HumanoidRootPart") then
                            lastBlockTpTime = tick()

                            task.spawn(function()
                                local startTime = tick()
                                while tick() - startTime < 0.5 do
                                    if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                                        local myRoot = lp.Character.HumanoidRootPart
                                        local targetHRP = killer.HumanoidRootPart
                                        local direction = targetHRP.CFrame.LookVector
                                        local tpPosition = targetHRP.Position + direction * 4
                                        myRoot.CFrame = CFrame.new(tpPosition)
                                    end
                                    task.wait()
                                end
                            end)
                            break
                        end
                    end
                end
                break
            end
        end
    end
end)


local Section = Tab:Section({ 
    Title = "n7",
})

local Toggle = Tab:Button({
    Title = "Load Auto Clon (Auto Clon 007n7)",
    Callback = function()
    
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local lp = Players.LocalPlayer

local autoBlockAudioOn = false
local cachedCooldown = nil

local detectionRange = 20
local detectionRangeSq = detectionRange * detectionRange

local autoBlockTriggerSounds = {
    ["102228729296384"] = true, ["140242176732868"] = true, ["112809109188560"] = true,
    ["136323728355613"] = true, ["115026634746636"] = true, ["84116622032112"] = true,
    ["108907358619313"] = true, ["127793641088496"] = true, ["86174610237192"] = true,
    ["95079963655241"] = true, ["101199185291628"] = true, ["119942598489800"] = true,
    ["84307400688050"] = true, ["113037804008732"] = true, ["105200830849301"] = true,
    ["75330693422988"] = true, ["82221759983649"] = true, ["81702359653578"] = true,
    ["108610718831698"] = true, ["112395455254818"] = true, ["109431876587852"] = true,
    ["109348678063422"] = true, ["85853080745515"] = true, ["12222216"] = true
}

local soundHooks = {}
local soundBlockedUntil = {}

-- ðŸ”¥ ÐÐ¾Ð²Ñ‹Ð¹ RemoteEvent Ð²Ñ‹Ð·Ð¾Ð²
local function fireRemoteBlock()
    local remote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
    local args = {
        "UseActorAbility",
        {
            buffer.fromstring("\"Clone\"")
        }
    }
    remote:FireServer(unpack(args))
end

local function isFacing(localRoot, targetRoot)
    local dir = (localRoot.Position - targetRoot.Position).Unit
    local dot = targetRoot.CFrame.LookVector:Dot(dir)
    return dot > -0.3
end

local function extractNumericSoundId(sound)
    if not sound or not sound.SoundId then return nil end
    local sid = tostring(sound.SoundId)
    local num = sid:match("%d+")
    if num then return num end
    return nil
end

local function getSoundWorldPosition(sound)
    if not sound then return nil end
    if sound.Parent and sound.Parent:IsA("BasePart") then
        return sound.Parent.Position, sound.Parent
    end
    if sound.Parent and sound.Parent:IsA("Attachment") and sound.Parent.Parent and sound.Parent.Parent:IsA("BasePart") then
        return sound.Parent.Parent.Position, sound.Parent.Parent
    end
    local found = sound.Parent and sound.Parent:FindFirstChildWhichIsA("BasePart", true)
    if found then
        return found.Position, found
    end
    return nil, nil
end

local function getCharacterFromDescendant(inst)
    if not inst then return nil end
    local model = inst:FindFirstAncestorOfClass("Model")
    if model and model:FindFirstChildOfClass("Humanoid") then
        return model
    end
    return nil
end

local function refreshUIRefs()
    local playerGui = lp:FindFirstChild("PlayerGui")
    if not playerGui then return end
    local main = playerGui:FindFirstChild("MainUI")
    if main then
        local ability = main:FindFirstChild("AbilityContainer")
        local blockBtn = ability and ability:FindFirstChild("Block")
        cachedCooldown = blockBtn and blockBtn:FindFirstChild("CooldownTime")
    else
        cachedCooldown = nil
    end
end

local function attemptBlockForSound(sound)
    if not autoBlockAudioOn or not sound or not sound:IsA("Sound") or not sound.IsPlaying then return end

    local id = extractNumericSoundId(sound)
    if not id or not autoBlockTriggerSounds[id] then return end

    local t = tick()
    if soundBlockedUntil[sound] and t < soundBlockedUntil[sound] then return end

    local myChar = lp.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end

    local soundPos, soundPart = getSoundWorldPosition(sound)
    if not soundPos or not soundPart then return end

    local char = getCharacterFromDescendant(soundPart)
    local plr = char and Players:GetPlayerFromCharacter(char)
    if not plr or plr == lp then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local dvec = hrp.Position - myRoot.Position
    if dvec:Dot(dvec) > detectionRangeSq then return end

    if cachedCooldown and cachedCooldown.Text ~= "" then return end

    if not isFacing(myRoot, hrp) then return end

    fireRemoteBlock()
    soundBlockedUntil[sound] = t + 1.2
end

local function hookSound(sound)
    if not sound or not sound:IsA("Sound") or soundHooks[sound] then return end

    local playedConn = sound.Played:Connect(function() pcall(attemptBlockForSound, sound) end)
    local propConn = sound:GetPropertyChangedSignal("IsPlaying"):Connect(function()
        if sound.IsPlaying then pcall(attemptBlockForSound, sound) end
    end)
    local destroyConn
    destroyConn = sound.Destroying:Connect(function()
        if playedConn and playedConn.Connected then playedConn:Disconnect() end
        if propConn and propConn.Connected then propConn:Disconnect() end
        if destroyConn and destroyConn.Connected then destroyConn:Disconnect() end
        soundHooks[sound] = nil
        soundBlockedUntil[sound] = nil
    end)

    soundHooks[sound] = {playedConn, propConn, destroyConn}

    if sound.IsPlaying then
        task.spawn(function() pcall(attemptBlockForSound, sound) end)
    end
end

lp.CharacterAdded:Connect(function()
    task.delay(0.5, refreshUIRefs)
end)
refreshUIRefs()

for _, desc in ipairs(game:GetDescendants()) do
    if desc:IsA("Sound") then pcall(hookSound, desc) end
end
game.DescendantAdded:Connect(function(desc)
    if desc:IsA("Sound") then pcall(hookSound, desc) end
end)

local Toggle = Tab:Toggle({
    Title = "Auto Clon (Auto Clon 007n7)",
    Default = autoBlockAudioOn,
    Callback = function(state)
        autoBlockAudioOn = state
    end
})

local Toggle = Tab:Slider({
    Title = "Detection Range (Auto Clon 007n7)",
    Step = 1,
    Value = {Min = 1, Max = 100, Default = detectionRange},
    Suffix = " studs",
    Callback = function(val)
        detectionRange = val
        detectionRangeSq = val * val
    end
})

end
})

local Tab = Window:Tab({
    Title = "Misc",
    Icon = "anchor", -- optional
    Locked = false,
})

local TextChatService = game:GetService("TextChatService")

local Button = Tab:Button({
    Title = "Chat visibility",
    Callback = function()
        if TextChatService:FindFirstChild("ChatWindowConfiguration") and TextChatService:FindFirstChild("ChatInputBarConfiguration") then
            TextChatService.ChatWindowConfiguration.Enabled = true
            TextChatService.ChatInputBarConfiguration.Enabled = true
            print("Ð Â§Ð Â°Ð¡â€š Ð Ð†Ð Ñ”Ð Â»Ð¡Ð‹Ð¡â€¡Ð¡â€˜Ð Ð…!")
        else
            warn("ChatWindowConfiguration Ð Ñ‘Ð Â»Ð Ñ‘ ChatInputBarConfiguration Ð Ð…Ð Âµ Ð Ð…Ð Â°Ð â„–Ð Ò‘Ð ÂµÐ Ð…Ð¡â€¹!")
        end
    end
})

local fullbrightActive = false
local originalSettings = {}

local function applyFullbright()
    if not fullbrightActive then return end
    Lighting.Ambient = Color3.new(1,1,1)
    Lighting.OutdoorAmbient = Color3.new(1,1,1)
    Lighting.Brightness = 2
    Lighting.ClockTime = 12
end

local function revertFullbright()
    if originalSettings.Ambient then
        Lighting.Ambient = originalSettings.Ambient
        Lighting.OutdoorAmbient = originalSettings.OutdoorAmbient
        Lighting.Brightness = originalSettings.Brightness
        Lighting.ClockTime = originalSettings.ClockTime
    end
end

local Toggle = Tab:Toggle({
    Title = "Fullbright",
    Default = false,
    Callback = function(state)
        fullbrightActive = state
        if fullbrightActive then
            if not originalSettings.Ambient then
                originalSettings.Ambient = Lighting.Ambient
                originalSettings.OutdoorAmbient = Lighting.OutdoorAmbient
                originalSettings.Brightness = Lighting.Brightness
                originalSettings.ClockTime = Lighting.ClockTime
            end
            applyFullbright()
        else
            revertFullbright()
        end
    end
})

local antiFogActive = false
local disabledFogElements = {}

local Toggle = Tab:Toggle({
    Title = "Anti Fog",
    Default = false,
    Callback = function(state)
        antiFogActive = state
        if antiFogActive then
            disabledFogElements = {}
            for _, v in ipairs(Lighting:GetChildren()) do
                if v:IsA("Atmosphere") or v:IsA("Sky") then
                    table.insert(disabledFogElements, v)
                    v.Parent = nil
                end
            end
        else
            for _, v in ipairs(disabledFogElements) do
                if v then
                    v.Parent = Lighting
                end
            end
            disabledFogElements = {}
        end
    end
})

local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local LP = Players.LocalPlayer
local PlayerGui = LP:WaitForChild("PlayerGui")

local ActiveRemoveEffects = false
local removeEffectsLoop

-- Ð ÐŽÐ Ñ—Ð Ñ‘Ð¡ÐƒÐ Ñ•Ð Ñ” Ð Ñ‘Ð Â·Ð Ð†Ð ÂµÐ¡ÐƒÐ¡â€šÐ Ð…Ð¡â€¹Ð¡â€¦ Ð¡ÐŒÐ¡â€žÐ¡â€žÐ ÂµÐ Ñ”Ð¡â€šÐ Ñ•Ð Ð†
local effectNames = {
    "BlurEffect", "ColorCorrectionEffect", "BloomEffect", "SunRaysEffect", 
    "DepthOfFieldEffect", "ScreenFlash", "HitEffect", "DamageOverlay", 
    "BloodEffect", "Vignette", "BlackScreen", "WhiteScreen", "ShockEffect",
    "Darkness", "JumpScare", "LowHealthOverlay", "Flashbang", "FadeEffect"
}

local effectClasses = {
    "BlurEffect",
    "BloomEffect",
    "SunRaysEffect",
    "DepthOfFieldEffect",
    "ColorCorrectionEffect"
}

local function removeEffects()
    -- Ð ÐˆÐ Â±Ð Ñ‘Ð¡Ð‚Ð Â°Ð ÂµÐ Ñ˜ Ð¡ÐŒÐ¡â€žÐ¡â€žÐ ÂµÐ Ñ”Ð¡â€šÐ¡â€¹ Ð Ñ‘Ð Â· Lighting
    for _, obj in pairs(Lighting:GetDescendants()) do
        if table.find(effectNames, obj.Name) or table.find(effectClasses, obj.ClassName) then
            obj:Destroy()
        end
    end

    -- Ð ÐˆÐ Â±Ð Ñ‘Ð¡Ð‚Ð Â°Ð ÂµÐ Ñ˜ GUI-Ð Ñ•Ð Ð†Ð ÂµÐ¡Ð‚Ð Â»Ð ÂµÐ Ñ‘
    for _, obj in pairs(PlayerGui:GetDescendants()) do
        if table.find(effectNames, obj.Name) then
            obj:Destroy()
        elseif obj:IsA("ScreenGui") or obj:IsA("BillboardGui") or obj:IsA("SurfaceGui") then
            if obj:FindFirstChildWhichIsA("ImageLabel") or obj:FindFirstChildWhichIsA("Frame") then
                if table.find(effectNames, obj.Name) or obj.Name:lower():find("overlay") or obj.Name:lower():find("effect") then
                    obj:Destroy()
                end
            end
        end
    end
end

local Toggle = Tab:Toggle({
    Title = "Remove Effects",
    Default = true,
    Callback = function(state)
        ActiveRemoveEffects = state
        if state then
            if removeEffectsLoop then
                task.cancel(removeEffectsLoop)
                removeEffectsLoop = nil
            end
            removeEffectsLoop = task.spawn(function()
                while ActiveRemoveEffects do
                    removeEffects()
                    task.wait(0.5)
                end
            end)
        else
            if removeEffectsLoop then
                task.cancel(removeEffectsLoop)
                removeEffectsLoop = nil
            end
        end
    end
})

-- ANTI SLOWS 
local Survivors = workspace:WaitForChild("Players"):WaitForChild("Survivors")
local RunService = game:GetService("RunService")

-- Anti-Slow Configs
local AntiSlowConfigs = {
    Slowness = {Values = {"SlowedStatus"}, Connection = nil, Enabled = false},
    Skills = {Values = {"StunningKiller", "EatFriedChicken", "GuestBlocking", "PunchAbility", "SubspaceTripmine",
                        "TaphTripwire", "PlasmaBeam", "SpawnProtection", "c00lgui", "ShootingGun", 
                        "TwoTimeStab", "TwoTimeCrouching", "DrinkingCola", "DrinkingSlateskin", 
                        "SlateskinStatus", "EatingGhostburger"}, Connection = nil, Enabled = false},
    Items = {Values = {"BloxyColaItem", "Medkit"}, Connection = nil, Enabled = false},
    Emotes = {Values = {"Emoting"}, Connection = nil, Enabled = false},
    Builderman = {Values = {"DispenserConstruction", "SentryConstruction"}, Connection = nil, Enabled = false}
}

-- Hide Slowness UI
local function hideSlownessUI()
    local mainUI = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("MainUI")
    if mainUI then
        local statusContainer = mainUI:FindFirstChild("StatusContainer")
        if statusContainer then
            local slownessUI = statusContainer:FindFirstChild("Slowness")
            if slownessUI then
                slownessUI.Visible = false
            end
        end
    end
end

-- Handle Anti-Slow
local function handleAntiSlow(survivor, config)
    if survivor:GetAttribute("Username") ~= game:GetService("Players").LocalPlayer.Name then return end
    local function onRenderStep()
        if not survivor.Parent or not config.Enabled then return end
        local speedMultipliers = survivor:FindFirstChild("SpeedMultipliers")
        if speedMultipliers then
            for _, valName in ipairs(config.Values) do
                local val = speedMultipliers:FindFirstChild(valName)
                if val and val:IsA("NumberValue") and val.Value ~= 1 then
                    val.Value = 1
                end
            end
        end
        hideSlownessUI()
    end

    config.Connection = RunService.RenderStepped:Connect(onRenderStep)
end

-- Start Anti-Slow
local function startAntiSlow(config)
    config.Enabled = true
    for _, survivor in pairs(Survivors:GetChildren()) do
        handleAntiSlow(survivor, config)
    end
    Survivors.ChildAdded:Connect(function(child)
        task.wait(0.1)
        handleAntiSlow(child, config)
    end)
end

-- Stop Anti-Slow
local function stopAntiSlow(config)
    config.Enabled = false
    if config.Connection then
        config.Connection:Disconnect()
        config.Connection = nil
    end
end

local Toggle = Tab:Toggle({
    Title = "Anti Slow",
    Default = false,
    Callback = function(state)
        for _, config in pairs(AntiSlowConfigs) do
            if state then
                startAntiSlow(config)
            else
                stopAntiSlow(config)
            end
        end
    end
})

local Button = Tab:Button({
    Title = "Load Invisibility",
    Callback = function()
    
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local animationId = "75804462760596"
local animationSpeed = 0
local loopRunning = false
local loopThread
local currentAnim = nil

function StartInvisibility()
    loopRunning = true
    local speaker = LocalPlayer
    local humanoid = speaker.Character and speaker.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.RigType ~= Enum.HumanoidRigType.R6 then return end

    loopThread = task.spawn(function()
        while loopRunning do
            local anim = Instance.new("Animation")
            anim.AnimationId = "rbxassetid://" .. animationId
            local loadedAnim = humanoid:LoadAnimation(anim)
            currentAnim = loadedAnim
            loadedAnim.Looped = false
            loadedAnim:Play()
            loadedAnim:AdjustSpeed(animationSpeed)
            task.wait(0.000001)
        end
    end)
end

function StopInvisibility()
    loopRunning = false
    if loopThread then
        task.cancel(loopThread)
        loopThread = nil
    end
    if currentAnim then
        currentAnim:Stop()
        currentAnim = nil
    end
    local speaker = LocalPlayer
    local humanoid = speaker.Character and (speaker.Character:FindFirstChildOfClass("Humanoid") or speaker.Character:FindFirstChildOfClass("AnimationController"))
    if humanoid then
        for _, v in pairs(humanoid:GetPlayingAnimationTracks()) do
            v:AdjustSpeed(100000)
        end
    end
    local animateScript = speaker.Character and speaker.Character:FindFirstChild("Animate")
    if animateScript then
        animateScript.Disabled = true
        animateScript.Disabled = false
    end
end

local Toggle = Tab:Toggle({
    Title = "Invisibility(R6 only)",
    Default = false,
    Callback = function(state)
        if state then
            StartInvisibility()
        else
            StopInvisibility()
        end
    end
})

end
})

--NOLI ANTI WALL CRUSH 
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Remote = game:GetService("ReplicatedStorage").Modules.Network.RemoteEvent

-- Ð â€œÐ Â»Ð Ñ•Ð Â±Ð Â°Ð Â»Ð¡ÐŠÐ Ð…Ð¡â€¹Ð Âµ Ð Ñ—Ð ÂµÐ¡Ð‚Ð ÂµÐ Ñ˜Ð ÂµÐ Ð…Ð Ð…Ð¡â€¹Ð Âµ
getgenv()._oldFireServer = getgenv()._oldFireServer or nil
getgenv()._VoidRushBypass = getgenv()._VoidRushBypass or false -- toggle Ð¡ÐƒÐ Ñ•Ð¡ÐƒÐ¡â€šÐ Ñ•Ð¡ÐÐ Ð…Ð Ñ‘Ð Âµ

-- Ð ÒÐ¡Ñ“Ð Ñ” Ð¡ÐƒÐ¡â€šÐ Â°Ð Ð†Ð Ñ‘Ð Ñ˜ Ð¡â€šÐ Ñ•Ð Â»Ð¡ÐŠÐ Ñ”Ð Ñ• Ð Ñ•Ð Ò‘Ð Ñ‘Ð Ð… Ð¡Ð‚Ð Â°Ð Â·
if not getgenv()._oldFireServer then
    local old
    old = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        if self == Remote and method == "FireServer" then
            if args[1] == LocalPlayer.Name .. "VoidRushCollision" then
                if getgenv()._VoidRushBypass then
                    return -- Ð Â±Ð Â»Ð Ñ•Ð Ñ”Ð Ñ‘Ð¡Ð‚Ð¡Ñ“Ð ÂµÐ Ñ˜ Ð¡â€šÐ Ñ•Ð Â»Ð¡ÐŠÐ Ñ”Ð Ñ• Ð ÂµÐ¡ÐƒÐ Â»Ð Ñ‘ toggle Ð Ð†Ð Ñ”Ð Â»Ð¡Ð‹Ð¡â€¡Ð¡â€˜Ð Ð…
                end
            end
        end
        return old(self, ...)
    end)

    getgenv()._oldFireServer = old
end

-- Ð â€Ð Ñ•Ð Â±Ð Â°Ð Ð†Ð Â»Ð¡ÐÐ ÂµÐ Ñ˜ Toggle Ð Ð† GUI
local Toggle = Tab:Toggle({
    Title = "VoidRush No-Crash",
    Default = false,
    Callback = function(state)
        getgenv()._VoidRushBypass = state
    end
})

--NOLI FULL VOID CONTROL 
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local voidrushcontrol = false
local ORIGINAL_DASH_SPEED = 60
local isOverrideActive = false
local connection

-- Ð ÑŸÐ ÂµÐ¡Ð‚Ð ÂµÐ Ñ˜Ð ÂµÐ Ð…Ð Ð…Ð¡â€¹Ð Âµ Ð Ñ—Ð ÂµÐ¡Ð‚Ð¡ÐƒÐ Ñ•Ð Ð…Ð Â°Ð Â¶Ð Â°
local humanoid, rootPart
local function setupCharacter(character)
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
end

if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end

LocalPlayer.CharacterAdded:Connect(setupCharacter)

local Toggle = Tab:Toggle({
    Title = "Void Rush full Control (Noli)",
    Default = false,
    Callback = function(state)
        voidrushcontrol = state
    end
})

-- Ð Â¤Ð¡Ñ“Ð Ð…Ð Ñ”Ð¡â€ Ð Ñ‘Ð¡Ð Ð¡ÐƒÐ¡â€šÐ Â°Ð¡Ð‚Ð¡â€šÐ Â° Ð Ñ•Ð Ð†Ð ÂµÐ¡Ð‚Ð¡Ð‚Ð Â°Ð â„–Ð Ò‘Ð Â°
local function startOverride()
    if isOverrideActive then return end
    isOverrideActive = true

    connection = RunService.RenderStepped:Connect(function()
        if not humanoid or not rootPart then return end

        humanoid.WalkSpeed = ORIGINAL_DASH_SPEED
        humanoid.AutoRotate = false

        local direction = rootPart.CFrame.LookVector
        local horizontal = Vector3.new(direction.X, 0, direction.Z)
        if horizontal.Magnitude > 0 then
            humanoid:Move(horizontal.Unit)
        end
    end)
end

-- Ð Â¤Ð¡Ñ“Ð Ð…Ð Ñ”Ð¡â€ Ð Ñ‘Ð¡Ð Ð Ñ•Ð¡ÐƒÐ¡â€šÐ Â°Ð Ð…Ð Ñ•Ð Ð†Ð Ñ”Ð Ñ‘ Ð Ñ•Ð Ð†Ð ÂµÐ¡Ð‚Ð¡Ð‚Ð Â°Ð â„–Ð Ò‘Ð Â°
local function stopOverride()
    if not isOverrideActive then return end
    isOverrideActive = false

    if humanoid then
        humanoid.WalkSpeed = 16 -- Ð Ò‘Ð ÂµÐ¡â€žÐ Ñ•Ð Â»Ð¡â€šÐ Ð…Ð Â°Ð¡Ð Ð¡ÐƒÐ Ñ”Ð Ñ•Ð¡Ð‚Ð Ñ•Ð¡ÐƒÐ¡â€šÐ¡ÐŠ
        humanoid.AutoRotate = true
        humanoid:Move(Vector3.new(0, 0, 0))
    end

    if connection then
        connection:Disconnect()
        connection = nil
    end
end

-- Ð â€œÐ Â»Ð Â°Ð Ð†Ð Ð…Ð¡â€¹Ð â„– Ð¡â€ Ð Ñ‘Ð Ñ”Ð Â»
RunService.RenderStepped:Connect(function()
    if not voidrushcontrol then return end

    local char = humanoid and humanoid.Parent
    local voidRushState = char and char:GetAttribute("VoidRushState")

    if voidRushState == "Dashing" then
        startOverride()
    else
        stopOverride()
    end
end)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local hpThreshold = 50
local autoPizzaEnabled = false
local healthConnection
local charAddedConnection

local function log(msg)
    print("[AutoPizzaHeal] " .. msg)
end

local function teleportTo(position)
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        char.HumanoidRootPart.CFrame = CFrame.new(position)
        log("Ð ÑžÐ ÂµÐ Â»Ð ÂµÐ Ñ—Ð Ñ•Ð¡Ð‚Ð¡â€š Ð Ñ”: " .. tostring(position))
    end
end

local function tryPizzaHeal()
    local character = LocalPlayer.Character
    if not character then return end

    local humanoid = character:FindFirstChild("Humanoid")
    local root = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not root then
        log("Ð²ÑœÐŠ Ð ÑœÐ Âµ Ð Ð…Ð Â°Ð â„–Ð Ò‘Ð ÂµÐ Ð… Humanoid Ð Ñ‘Ð Â»Ð Ñ‘ HumanoidRootPart")
        return
    end

    local startPos = root.Position
    local beforeHP = humanoid.Health

    local pizza = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame") and workspace.Map.Ingame:FindFirstChild("Pizza")
    if not pizza or not pizza:IsA("BasePart") then
        log("Ð²ÑœÐŠ Pizza Ð Ð…Ð Âµ Ð Ð…Ð Â°Ð â„–Ð Ò‘Ð ÂµÐ Ð…Ð Â° Ð Ñ‘Ð Â»Ð Ñ‘ Ð Ð…Ð Âµ Ð¡ÐÐ Ð†Ð Â»Ð¡ÐÐ ÂµÐ¡â€šÐ¡ÐƒÐ¡Ð BasePart")
        return
    end

    teleportTo(pizza.Position)
    task.wait(0.5)

    if humanoid.Health <= beforeHP then
        log("Ñ€ÑŸÐŒâ€¢ HP Ð Ð…Ð Âµ Ð Ð†Ð Ñ•Ð¡ÐƒÐ¡ÐƒÐ¡â€šÐ Â°Ð Ð…Ð Ñ•Ð Ð†Ð Â»Ð ÂµÐ Ð…Ð Ñ•, Ð Â¶Ð Ò‘Ð¡â€˜Ð Ñ˜ Ð ÂµÐ¡â€°Ð¡â€˜ 0.5 Ð¡ÐƒÐ ÂµÐ Ñ”")
        task.wait(0.5)
    end

    teleportTo(startPos)
    log("Ð²â€ Â©Ð¿Ñ‘Ð Ð â€™Ð Ñ•Ð Â·Ð Ð†Ð¡Ð‚Ð Â°Ð¡â€š Ð Ð…Ð Â° Ð Ñ‘Ð¡ÐƒÐ¡â€¦Ð Ñ•Ð Ò‘Ð Ð…Ð¡Ñ“Ð¡Ð‹ Ð Ñ—Ð Ñ•Ð Â·Ð Ñ‘Ð¡â€ Ð Ñ‘Ð¡Ð‹")
end

local function setupHealthMonitor(character)
    if healthConnection then
        healthConnection:Disconnect()
    end

    local humanoid = character:WaitForChild("Humanoid", 5)
    if not humanoid then
        log("Ð²ÑœÐŠ Humanoid Ð Ð…Ð Âµ Ð Ð…Ð Â°Ð â„–Ð Ò‘Ð ÂµÐ Ð…")
        return
    end

    log("Ð²Ñšâ€¦ Ð ÑšÐ Ñ•Ð Ð…Ð Ñ‘Ð¡â€šÐ Ñ•Ð¡Ð‚Ð Ñ‘Ð Ð…Ð Ñ– HP Ð Â°Ð Ñ”Ð¡â€šÐ Ñ‘Ð Ð†Ð ÂµÐ Ð…")

    healthConnection = humanoid.HealthChanged:Connect(function(currentHP)
        if autoPizzaEnabled and currentHP < hpThreshold and currentHP > 0 then
            log("Ð²Ñ™ Ð¿Ñ‘Ð HP Ð Ð…Ð Ñ‘Ð Â¶Ð Âµ Ð Ñ—Ð Ñ•Ð¡Ð‚Ð Ñ•Ð Ñ–Ð Â°: " .. currentHP)
            tryPizzaHeal()
        end
    end)
end

-- Ð ÑŸÐ Ñ•Ð Ò‘Ð Ñ”Ð Â»Ð¡Ð‹Ð¡â€¡Ð ÂµÐ Ð…Ð Ñ‘Ð Âµ Ð Ñ—Ð¡Ð‚Ð Ñ‘ Ð¡ÐƒÐ¡â€šÐ Â°Ð¡Ð‚Ð¡â€šÐ Âµ
if LocalPlayer.Character then
    setupHealthMonitor(LocalPlayer.Character)
end

charAddedConnection = LocalPlayer.CharacterAdded:Connect(setupHealthMonitor)

-- Ð²ÐÂ¬ Ð ÐŽÐ Ñ•Ð Â·Ð Ò‘Ð Â°Ð Ð…Ð Ñ‘Ð Âµ UI Ð Ð† Ð Ñ”Ð Ñ•Ð Ð…Ð¡â€ Ð Âµ, Ð Ñ”Ð Â°Ð Ñ” Ð¡â€šÐ¡â€¹ Ð Ñ—Ð¡Ð‚Ð Ñ•Ð¡ÐƒÐ Ñ‘Ð Â»
local Toggle = Tab:Toggle({
    Title = "Auto Eat Pizza",
    Default = false,
    Callback = function(v)
        autoPizzaEnabled = v
        log("Auto Pizza: " .. (v and "Ð²Ñšâ€¦ Ð â€™Ð Ñ™Ð â€º" or "Ð²ÑœÐŠ Ð â€™Ð Â«Ð Ñ™Ð â€º"))
    end
})

local Slider = Tab:Slider({
    Title = "HP Threshold",
    Value = {Min = 1, Max = 100, Default = hpThreshold},
    Step = 1,
    Suffix = "%",
    Callback = function(val)
        hpThreshold = val
        log("Ð ÑŸÐ Ñ•Ð¡Ð‚Ð Ñ•Ð Ñ– HP Ð¡Ñ“Ð¡ÐƒÐ¡â€šÐ Â°Ð Ð…Ð Ñ•Ð Ð†Ð Â»Ð ÂµÐ Ð… Ð Ð…Ð Â°: " .. val)
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local cooldown = false
local backOffset = Vector3.new(0, 0, 3)
local hpThreshold = 50
local featureEnabled = false

-- UI
local Toggle = Tab:Toggle({
    Title = "Auto heal Teammates (Elliot)",
    Default = false,
    Callback = function(value)
        featureEnabled = value
    end
})

local Slider = Tab:Slider({
    Title = "HP Threshold",
    Step = 1,
    Value = {Min = 1, Max = 100, Default = hpThreshold},
    Suffix = "HP",
    Callback = function(value)
        hpThreshold = tonumber(value)
    end
})

-- Ñ‚ÐµÐ»ÐµÐ¿Ð¾Ñ€Ñ‚ Ð·Ð° ÑÐ¿Ð¸Ð½Ñƒ + ÐºÐ¸Ð´Ð°Ð½Ð¸Ðµ Ð¿Ð¸Ñ†Ñ†Ñ‹
local function teleportBehind(targetChar)
    if not targetChar or not targetChar:FindFirstChild("HumanoidRootPart") then return end
    
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end

    local rootPart = character.HumanoidRootPart
    local targetRootPart = targetChar.HumanoidRootPart
    
    local returnPos = rootPart.CFrame

    -- "Ð¿Ñ€Ð¸Ð»Ð¸Ð¿Ð°Ð½Ð¸Ðµ" Ð·Ð° ÑÐ¿Ð¸Ð½Ð¾Ð¹
    local stickConnection
    stickConnection = RunService.Heartbeat:Connect(function()
        if not targetRootPart or not targetRootPart.Parent or not rootPart or not rootPart.Parent then
            stickConnection:Disconnect()
            return
        end
        
        local backPos = targetRootPart.CFrame * CFrame.new(backOffset)
        rootPart.CFrame = backPos
    end)
    
    -- Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ remote
    local args = {
        "UseActorAbility",
        {
            buffer.fromstring("\"ThrowPizza\"")
        }
    }
    ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))

    -- Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‚ Ñ‡ÐµÑ€ÐµÐ· 2 ÑÐµÐº
    task.delay(2, function()
        stickConnection:Disconnect()
        if character and rootPart and rootPart.Parent then
            rootPart.CFrame = returnPos
        end
    end)
end

-- Ð¼Ð¾Ð½Ð¸Ñ‚Ð¾Ñ€Ð¸Ð½Ð³ HP ÑÐ¾ÑŽÐ·Ð½Ð¸ÐºÐ°
local function monitorPlayerHP(player)
    local function onCharacterAdded(character)
        local humanoid = character:WaitForChild("Humanoid", 5)
        if humanoid then
            humanoid.HealthChanged:Connect(function(currentHP)
                if featureEnabled and not cooldown and currentHP > 0 and currentHP < hpThreshold then
                    cooldown = true
                    teleportBehind(character)
                    task.delay(46, function()
                        cooldown = false
                    end)
                end
            end)
        end
    end

    if player.Character then
        onCharacterAdded(player.Character)
    end

    player.CharacterAdded:Connect(onCharacterAdded)
end

-- ÑÐ»ÐµÐ´Ð¸Ð¼ Ð·Ð° Ð²ÑÐµÐ¼Ð¸ Ð¸Ð³Ñ€Ð¾ÐºÐ°Ð¼Ð¸ ÐºÑ€Ð¾Ð¼Ðµ ÑÐµÐ±Ñ
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        monitorPlayerHP(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        monitorPlayerHP(player)
    end
end)


-- AAAA
local Button = Tab:Button({
    Title = "Load Auto RaginPace(Slasher)",
    Callback = function()
    
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local lp = Players.LocalPlayer
local playerGui = lp:WaitForChild("PlayerGui")

-- == Persistent Storage ==
local savedRange = lp:FindFirstChild("RagingPaceRange")
if not savedRange then
    savedRange = Instance.new("NumberValue")
    savedRange.Name = "RagingPaceRange"
    savedRange.Value = 19 -- default range
    savedRange.Parent = lp
end

local savedEnabled = lp:FindFirstChild("RagingPaceEnabled")
if not savedEnabled then
    savedEnabled = Instance.new("BoolValue")
    savedEnabled.Name = "RagingPaceEnabled"
    savedEnabled.Value = false -- default state
    savedEnabled.Parent = lp
end

local RANGE = savedRange.Value
local SPAM_DURATION = 3
local COOLDOWN_TIME = 5
local activeCooldowns = {}
local enabled = savedEnabled.Value

-- == Animation ID List ==
local animsToDetect = {
    ["116618003477002"] = true,
    ["119462383658044"] = true,
    ["131696603025265"] = true,
    ["121255898612475"] = true,
    ["133491532453922"] = true,
    ["103601716322988"] = true,
    ["86371356500204"] = true,
    ["72722244508749"] = true,
    ["87259391926321"] = true,
    ["96959123077498"] = true,
}

-- == Remote ==
local function fireRagingPace()
    local args = {
        "UseActorAbility",
        {
            buffer.fromstring("\"RagingPace\"")
        }
    }
    ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
end

-- == Animation Checker ==
local function isAnimationMatching(anim)
    local id = tostring(anim.Animation and anim.Animation.AnimationId or "")
    local numId = id:match("%d+")
    return animsToDetect[numId] or false
end

-- == Main Detection ==
RunService.Heartbeat:Connect(function()
    if not enabled then return end

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= lp and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local targetHRP = player.Character.HumanoidRootPart
            local myChar = lp.Character
            if myChar and myChar:FindFirstChild("HumanoidRootPart") then
                local dist = (targetHRP.Position - myChar.HumanoidRootPart.Position).Magnitude
                if dist <= RANGE and (not activeCooldowns[player] or tick() - activeCooldowns[player] >= COOLDOWN_TIME) then
                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
                            if isAnimationMatching(track) then
                                activeCooldowns[player] = tick()
                                task.spawn(function()
                                    local startTime = tick()
                                    while tick() - startTime < SPAM_DURATION do
                                        fireRagingPace()
                                        task.wait(0.05)
                                    end
                                end)
                                break
                            end
                        end
                    end
                end
            end
        end
    end
end)

-- == UI ==
local Toggle = Tab:Toggle({
    Title = "RagingPace(slasher)",
    Default = enabled,
    Callback = function(state)
        enabled = state
        savedEnabled.Value = state
    end
})

local Slider = Tab:Slider({
    Title = "RagingPace Range",
    Step = 1,
    Value = {Min = 1, Max = 30, Default = RANGE},
    Suffix = "studs",
    Callback = function(val)
        RANGE = val
        savedRange.Value = val -- ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð² persistent value
    end
})

end
})

-- HSHSHSHDHDHDHDHDHEIIEJDJXJXNDDN

local Button = Tab:Button({
    Title = "Load Auto Error 404",
    Callback = function()
        local Players = game:GetService("Players")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local lp = Players.LocalPlayer

        -- Vars
        local autoErrorEnabled = false
        local detectionRange = 14
        local soundHooks = {}
        local soundTriggeredUntil = {}

        -- Trigger sounds
        local autoErrorTriggerSounds = {
            ["86710781315432"] = true,
            ["99820161736138"] = true,
            ["609342351"] = true,
            ["81976396729343"] = true,
            ["12222225"] = true,
            ["80521472651047"] = true,
            ["139012439429121"] = true,
            ["91194698358028"] = true,
            ["111910850942168"] = true,
            ["83851356262523"] = true,
        }

        -- Helpers
        local function extractNumericSoundId(sound)
            if not sound or not sound.SoundId then return nil end
            return tostring(sound.SoundId):match("%d+")
        end

        local function getSoundWorldPosition(sound)
            if sound.Parent and sound.Parent:IsA("BasePart") then
                return sound.Parent.Position
            elseif sound.Parent and sound.Parent:IsA("Attachment") and sound.Parent.Parent:IsA("BasePart") then
                return sound.Parent.Parent.Position
            end
            local found = sound.Parent and sound.Parent:FindFirstChildWhichIsA("BasePart", true)
            if found then return found.Position end
            return nil
        end

        local function attemptError404ForSound(sound)
            if not autoErrorEnabled then return end
            if not sound or not sound:IsA("Sound") or not sound.IsPlaying then return end

            local id = extractNumericSoundId(sound)
            if not id or not autoErrorTriggerSounds[id] then return end

            local myRoot = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
            if not myRoot then return end

            if soundTriggeredUntil[sound] and tick() < soundTriggeredUntil[sound] then return end

            local pos = getSoundWorldPosition(sound)
            local shouldTrigger = (not pos) or ((myRoot.Position - pos).Magnitude <= detectionRange)

            if shouldTrigger then
                warn("[AUTO ERROR 404] Triggered for Sound ID:", id)
                local args = {
                    "UseActorAbility",
                    {
                        buffer.fromstring("\"404Error\"")
                    }
                }
                ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
                soundTriggeredUntil[sound] = tick() + 1.2
            end
        end

        local function hookSound(sound)
            if soundHooks[sound] then return end
            
            local connections = {}
            
            local playedConn = sound.Played:Connect(function() 
                attemptError404ForSound(sound) 
            end)
            table.insert(connections, playedConn)
            
            local propConn = sound:GetPropertyChangedSignal("IsPlaying"):Connect(function()
                if sound.IsPlaying then 
                    attemptError404ForSound(sound) 
                end
            end)
            table.insert(connections, propConn)
            
            local destroyConn
            destroyConn = sound.Destroying:Connect(function()
                for _, conn in ipairs(connections) do
                    if conn and typeof(conn) == "RBXScriptConnection" then
                        pcall(function() conn:Disconnect() end)
                    end
                end
                if destroyConn and typeof(destroyConn) == "RBXScriptConnection" then
                    pcall(function() destroyConn:Disconnect() end)
                end
                soundHooks[sound] = nil
                soundTriggeredUntil[sound] = nil
            end)
            table.insert(connections, destroyConn)
            
            soundHooks[sound] = connections
            if sound.IsPlaying then 
                attemptError404ForSound(sound) 
            end
        end

        for _, s in ipairs(game:GetDescendants()) do
            if s:IsA("Sound") then 
                pcall(function() hookSound(s) end)
            end
        end

        game.DescendantAdded:Connect(function(d)
            if d:IsA("Sound") then 
                pcall(function() hookSound(d) end)
            end
        end)

        local Toggle = Tab:Toggle({
            Title = "Auto Error 404(John Doe)",
            Default = autoErrorEnabled,
            Callback = function(state)
                autoErrorEnabled = state
            end
        })

        local Slider = Tab:Slider({
            Title = "Error 404 Range",
            Step = 1,
            Value = {Min = 1, Max = 20, Default = detectionRange},
            Suffix = "studs",
            Callback = function(val)
                detectionRange = val
            end
        })
    end
})

local Players = game:GetService("Players")  
local Workspace = game:GetService("Workspace")  

-- Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð´Ð¸Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² (Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€ÑƒÐ¹ Ð¿Ð¾ Ð¶ÐµÐ»Ð°Ð½Ð¸ÑŽ)  
local killerDiameters = {  
	["Jason"] = 15,  
	["John Doe"] = 15,  
	["1x1x1x1"] = 15,  
	["Noli"] = 15,  
	["c00lkidd"] = 15,  
	["Slasher"] = 15  
}  

local circleColor = Color3.fromRGB(255, 105, 180) -- Ñ€Ð¾Ð·Ð¾Ð²Ñ‹Ð¹  

-- ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ ÐºÐ¾Ð»ÑŒÑ†Ð°  
local SEGMENTS = 96        
local SEGMENT_HEIGHT = 0.2 
local SEGMENT_WIDTH = 0.35 

local circles = {} -- circles[killer] = { model = Model, segments = {...}, diameter = number }  
local enabled = false -- Ñ„Ð»Ð°Ð³ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹  

local function createRingForKiller(killer, diameter)  
	if not killer or not killer.Parent then return end  
	local hrp = killer:FindFirstChild("HumanoidRootPart")  
	if not hrp then return end  

	if circles[killer] then  
		if circles[killer].model then  
			pcall(function() circles[killer].model:Destroy() end)  
		end  
		circles[killer] = nil  
	end  

	local model = Instance.new("Model")  
	model.Name = "HitboxRing_" .. killer.Name  
	model.Parent = Workspace  

	local radius = diameter / 2  
	local circumference = 2 * math.pi * radius  
	local segLen = circumference / SEGMENTS  

	local segments = {}  

	for i = 1, SEGMENTS do  
		local angle = (i - 1) * (2 * math.pi / SEGMENTS)  
		local offset = Vector3.new(radius * math.cos(angle), 0, radius * math.sin(angle))  
		local worldPos = hrp.Position + offset  

		local part = Instance.new("Part")  
		part.Size = Vector3.new(segLen, SEGMENT_HEIGHT, SEGMENT_WIDTH)  
		part.Anchored = false  
		part.CanCollide = false  
		part.Material = Enum.Material.Neon  
		part.Color = circleColor  
		part.Transparency = 0.3  
		part.CFrame = CFrame.new(worldPos) * CFrame.Angles(0, angle + math.pi/2, 0)  
		part.Parent = model  

		local weld = Instance.new("WeldConstraint")  
		weld.Part0 = part  
		weld.Part1 = hrp  
		weld.Parent = part  

		table.insert(segments, part)  
	end  

	circles[killer] = { model = model, segments = segments, diameter = diameter }  
end  

local function updateCircle(killer)  
	local hrp = killer:FindFirstChild("HumanoidRootPart")  
	if not hrp then return end  

	local diameter = killerDiameters[killer.Name]  
	if not diameter then return end  

	local info = circles[killer]  
	if not info then  
		createRingForKiller(killer, diameter)  
		return  
	end  

	if info.diameter ~= diameter then  
		createRingForKiller(killer, diameter)  
		return  
	end  
end  

local function cleanupCircles()  
	for killer, data in pairs(circles) do  
		if not killer.Parent then  
			if data.model then  
				pcall(function() data.model:Destroy() end)  
			end  
			circles[killer] = nil  
		end  
	end  
end  

local function clearAll()  
	for killer, data in pairs(circles) do  
		if data.model then  
			pcall(function() data.model:Destroy() end)  
		end  
	end  
	table.clear(circles)  
end  

task.spawn(function()  
	while true do  
		if enabled then  
			cleanupCircles()  
			if Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Killers") then  
				for _, killer in ipairs(Workspace.Players.Killers:GetChildren()) do  
					pcall(updateCircle, killer)  
				end  
			end  
		end  
		task.wait(5)  
	end  
end)  

local Toggle = Tab:Toggle({
    Title = "Hitbox visualization",
    Default = false,
    Callback = function(state)
        enabled = state
        if not state then
            clearAll()
        end
    end
})

local Tab = Window:Tab({
    Title = "Auto Stun",
    Icon = "bird", -- optional
    Locked = false,
})

local Button = Tab:Button({
    Title = "Load Auto Invisibility",
    Callback = function()

    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    -- ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¸
    local animationId = "75804462760596"
    local loopRunning = false
    local loopThread
    local currentAnim = nil

    -- GUI Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ
    local autoInvis = false
    local animationSpeed = 0
    local invisDuration = 5 -- Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ 5 ÑÐµÐºÑƒÐ½Ð´

    -- Toggle
    local Toggle = Tab:Toggle({
        Title = "Auto Invisibility when Clone (007n7)",
        Default = false,
        Callback = function(value)
            autoInvis = value
            if not autoInvis then
                StopInvisibility()
            end
        end
    })

    -- Slider Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚Ð¸ ÑÑ„Ñ„ÐµÐºÑ‚Ð° Invisibility
    local Slider = Tab:Slider({
        Title = "Invisibility Duration",
        Step = 1,
        Value = {Min = 1, Max = 45, Default = invisDuration},
        Suffix = "s",
        Callback = function(val)
            invisDuration = val
        end
    })

    -- Ð¤ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð·Ð°Ð¿ÑƒÑÐºÐ°/Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ¸ Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¸
    function StartInvisibility()
        if loopRunning then return end
        loopRunning = true
        print("[AutoInvis] Starting invisibility")

        local speaker = LocalPlayer
        local humanoid = speaker.Character and speaker.Character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.RigType ~= Enum.HumanoidRigType.R6 then return end

        loopThread = task.spawn(function()
            while loopRunning do
                local anim = Instance.new("Animation")
                anim.AnimationId = "rbxassetid://" .. animationId
                local loadedAnim = humanoid:LoadAnimation(anim)
                currentAnim = loadedAnim
                loadedAnim.Looped = false
                loadedAnim:Play()
                loadedAnim:AdjustSpeed(animationSpeed)
                while loadedAnim.IsPlaying and loopRunning do
                    loadedAnim:AdjustSpeed(animationSpeed)
                    task.wait(0.05)
                end
                task.wait(0.01)
            end
        end)
    end

    function StopInvisibility()
        loopRunning = false
        if loopThread then
            task.cancel(loopThread)
            loopThread = nil
        end
        if currentAnim then
            currentAnim:Stop()
            currentAnim = nil
        end
        local speaker = LocalPlayer
        local humanoid = speaker.Character and (speaker.Character:FindFirstChildOfClass("Humanoid") or speaker.Character:FindFirstChildOfClass("AnimationController"))
        if humanoid then
            for _, v in pairs(humanoid:GetPlayingAnimationTracks()) do
                v:AdjustSpeed(100000)
            end
        end
        local animateScript = speaker.Character and speaker.Character:FindFirstChild("Animate")
        if animateScript then
            animateScript.Disabled = true
            animateScript.Disabled = false
        end
        print("[AutoInvis] Stopped invisibility")
    end

    -- ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° GUI ÐºÐ°Ð¶Ð´Ñ‹Ðµ 0.1 ÑÐµÐºÑƒÐ½Ð´Ñ‹
    task.spawn(function()
        while true do
            task.wait(0.1)
            if autoInvis then
                local abilityContainer = LocalPlayer.PlayerGui:FindFirstChild("MainUI") 
                                        and LocalPlayer.PlayerGui.MainUI:FindFirstChild("AbilityContainer")
                local cloneGui = abilityContainer and abilityContainer:FindFirstChild("Clone")
                
                if cloneGui then
                    local cloneText = cloneGui:FindFirstChildOfClass("TextLabel")
                    local cloneValue = cloneText and tonumber(cloneText.Text)

                    if cloneValue and cloneValue >= 26 then
                        print("[AutoInvis] Clone count >= 26, activating invis")
                        StartInvisibility()
                        task.delay(invisDuration, StopInvisibility)
                        task.wait(invisDuration + 0.1) -- Ð–Ð´Ñ‘Ð¼, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð½Ðµ ÑÐ¿Ð°Ð¼Ð¸Ñ‚ÑŒ
                    end
                end
            end
        end
    end)

end
})

local autoStunChanceActive = false
local autoStunChanceThread = nil

local Toggle = Tab:Toggle({
    Title = "Auto Stun Killer(Chance)",
    Default = false,
    Callback = function(state)
        autoStunChanceActive = state
        if autoStunChanceActive then
            WindUI:Notify({ Title = "Auto Stun (Chance)", Content = "Enabled!", Duration = 2 })
            autoStunChanceThread = task.spawn(function()
                local function getBehindPosition(targetRoot, distance)
                    local back = -targetRoot.CFrame.LookVector * distance
                    return targetRoot.Position + back
                end

                local function stickToBack(playerRoot, targetRoot, duration, offset)
                    local startTime = tick()
                    while tick() - startTime < duration and autoStunChanceActive do
                        if not playerRoot or not targetRoot or not playerRoot.Parent or not targetRoot.Parent then break end
                        local behindPos = getBehindPosition(targetRoot, offset)
                        playerRoot.CFrame = CFrame.new(behindPos, targetRoot.Position)
                        RunService.Heartbeat:Wait()
                    end
                end

                local REMOTE = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
                local KILLERS_FOLDER = Workspace:WaitForChild("Players"):WaitForChild("Killers")
                local CHECK_RADIUS = 16
                local TELEPORT_DELAY = 2
                local CHECK_INTERVAL = 0.2
                local COOLDOWN = 43
                
                local lastActivation = 0

                while autoStunChanceActive do
                    task.wait(CHECK_INTERVAL)
                    if tick() - lastActivation < COOLDOWN then continue end

                    local char = LocalPlayer.Character
                    local root = char and char:FindFirstChild("HumanoidRootPart")
                    if not root then continue end

                    for _, killer in ipairs(KILLERS_FOLDER:GetChildren()) do
                        local targetRoot = killer:FindFirstChild("HumanoidRootPart")
                        if targetRoot and (root.Position - targetRoot.Position).Magnitude <= CHECK_RADIUS then
                            lastActivation = tick()
                            local originalCFrame = root.CFrame

                            REMOTE:FireServer("UseActorAbility", "Shoot")
                            WindUI:Notify({ Title = "Auto Stun (Chance)", Content = "Stunned killer: " .. killer.Name, Duration = 2 })

                            stickToBack(root, targetRoot, TELEPORT_DELAY, 3)

                            if root and root.Parent then
                                root.CFrame = originalCFrame
                            end

                            break
                        end
                    end
                end
            end)
        else
            if autoStunChanceThread then
                task.cancel(autoStunChanceThread)
                autoStunChanceThread = nil
            end
            WindUI:Notify({ Title = "Auto Stun (Chance)", Content = "Disabled!", Duration = 2 })
        end
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local active = false
local aimDuration = 1.7
local prediction = 4
local aimTargets = { "Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local trackedAnimations = {
    ["103601716322988"] = true,
    ["133491532453922"] = true,
    ["86371356500204"] = true,
    ["76649505662612"] = true,
    ["81698196845041"] = true
}

local Humanoid, HRP = nil, nil
local lastTriggerTime = 0
local aiming = false
local originalWS, originalJP, originalAutoRotate = nil, nil, nil

local function setupCharacter(char)
    Humanoid = char:WaitForChild("Humanoid")
    HRP = char:WaitForChild("HumanoidRootPart")
end

if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(setupCharacter)

local function getValidTarget()
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, name in ipairs(aimTargets) do
            local target = killersFolder:FindFirstChild(name)
            if target and target:FindFirstChild("HumanoidRootPart") then
                return target.HumanoidRootPart
            end
        end
    end
    return nil
end

local function getPlayingAnimationIds()
    local ids = {}
    if Humanoid then
        for _, track in ipairs(Humanoid:GetPlayingAnimationTracks()) do
            if track.Animation and track.Animation.AnimationId then
                local id = track.Animation.AnimationId:match("%d+")
                if id then
                    ids[id] = true
                end
            end
        end
    end
    return ids
end

RunService.RenderStepped:Connect(function()
    if not active or not Humanoid or not HRP then return end

    local playing = getPlayingAnimationIds()
    local triggered = false
    for id in pairs(trackedAnimations) do
        if playing[id] then
            triggered = true
            break
        end
    end

    if triggered then
        lastTriggerTime = tick()
        aiming = true
    end

    if aiming and tick() - lastTriggerTime <= aimDuration then
        if not originalWS then
            originalWS = Humanoid.WalkSpeed
            originalJP = Humanoid.JumpPower
            originalAutoRotate = Humanoid.AutoRotate
        end

        Humanoid.AutoRotate = false
        HRP.AssemblyAngularVelocity = Vector3.zero

        local targetHRP = getValidTarget()
        if targetHRP then
            local predictedPos = targetHRP.Position + (targetHRP.CFrame.LookVector * prediction)
            local direction = (predictedPos - HRP.Position).Unit
            local yRot = math.atan2(-direction.X, -direction.Z)
            HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, yRot, 0)
        end
    elseif aiming then
        aiming = false
        if originalWS and originalJP and originalAutoRotate ~= nil then
            Humanoid.WalkSpeed = originalWS
            Humanoid.JumpPower = originalJP
            Humanoid.AutoRotate = originalAutoRotate
            originalWS, originalJP, originalAutoRotate = nil, nil, nil
        end
    end
end)

local Toggle = Tab:Toggle({
    Title = "Chance Aimbot",
    Default = false,
    Callback = function(value)
        active = value
    end
})

local Slider = Tab:Slider({
    Title = "Sharpness (high ping = > 4)",
    Step = 1,
    Value = {Min = 1, Max = 10, Default = prediction},
    Suffix = "studs",
    Callback = function(val)
        prediction = val
    end
})

--BACKSTAB

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer

-- Vars
local enabled = false
local cooldown = false
local lastTarget = nil
local range = 4
local mode = "Behind"
local matchFacing = false
local attackType = "Normal"

local daggerRemote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
local killerNames = { "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

local counterAnimIDs = {
	"126830014841198", "126355327951215", "121086746534252", "18885909645",
	"98456918873918", "105458270463374", "83829782357897", "125403313786645",
	"118298475669935", "82113744478546", "70371667919898", "99135633258223",
	"97167027849946", "109230267448394", "139835501033932", "126896426760253",
	"109667959938617", "126681776859538", "129976080405072", "121293883585738",
	"81639435858902", "137314737492715", "92173139187970", "rbxassetid://126830014841198", "rbxassetid://126355327951215", "rbxassetid://121086746534252"
}

----------------------------------------------------------------
-- WindUI
----------------------------------------------------------------
local Toggle = Tab:Toggle({
    Title = "Backstab  ",
    Default = false,
    Callback = function(state)
        enabled = state
    end
})

local Slider = Tab:Slider({
    Title = "Backstab Range",
    Step = 0.5,
    Value = {Min = 1, Max = 30, Default = range},
    Suffix = " studs",
    Callback = function(val)
        local n = tonumber(val)
        if n then range = n end
    end
})

local Dropdown = Tab:Dropdown({
    Title = "Backstab Mode",
    Values = {"Behind", "Around"},
    Multi = false,
    AllowNone = false,
    Callback = function(selected)
        mode = selected
    end
})

local Dropdown = Tab:Dropdown({
    Title = "Backstab Type",
    Values = {"Normal", "Counter", "Legit"},
    Multi = false,
    AllowNone = false,
    Callback = function(selected)
        attackType = selected
    end
})

local Toggle = Tab:Toggle({
    Title = "AimBot fot legit mode",
    Default = false,
    Callback = function(state)
        matchFacing = state
    end
})

----------------------------------------------------------------
-- Helpers
----------------------------------------------------------------
local function killerPlayingCounterAnim(killer)
    local humanoid = killer:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then return false end

    for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
        local anim = track.Animation
        if anim and anim.AnimationId then
            local animIdNum = anim.AnimationId:match("%d+")
            for _, id in ipairs(counterAnimIDs) do
                if tostring(animIdNum) == id then
                    return true
                end
            end
        end
    end
    return false
end

local function isBehindTarget(hrp, targetHRP)
    local r = tonumber(range) or 4
    local distance = (hrp.Position - targetHRP.Position).Magnitude
    if distance > r then return false end

    if mode == "Around" then
        return true
    else
        local direction = -targetHRP.CFrame.LookVector
        local toPlayer = (hrp.Position - targetHRP.Position)
        return toPlayer:Dot(direction) > 0.5
    end
end

----------------------------------------------------------------
-- Cooldown text finder
----------------------------------------------------------------
local daggerCooldownText
local function refreshDaggerRef()
	local mainui = lp:FindFirstChild("PlayerGui") and lp.PlayerGui:FindFirstChild("MainUI")
	if mainui then
		local ability = mainui:FindFirstChild("AbilityContainer")
		if ability then
			local dagger = ability:FindFirstChild("Dagger")
			if dagger then
				local ct = dagger:FindFirstChild("CooldownTime")
				daggerCooldownText = ct
				return
			end
		end
	end
	daggerCooldownText = nil
end
lp.PlayerGui.DescendantAdded:Connect(refreshDaggerRef)
lp.PlayerGui.DescendantRemoving:Connect(function(obj)
	if obj == daggerCooldownText then
		daggerCooldownText = nil
	end
end)
refreshDaggerRef()

----------------------------------------------------------------
-- Main Loop
----------------------------------------------------------------
RunService.RenderStepped:Connect(function()
    if not daggerCooldownText or not daggerCooldownText.Parent then return end
    if tonumber(daggerCooldownText.Text or "") ~= nil then return end
    if not enabled or cooldown then return end
    
	local char = lp.Character
	if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
	local hrp = char.HumanoidRootPart

	local stats = game:GetService("Stats")
	local pingItem = stats.Network and stats.Network.ServerStatsItem and stats.Network.ServerStatsItem["Data Ping"]

	for _, name in ipairs(killerNames) do
		local killer = killersFolder:FindFirstChild(name)
		if killer and killer:FindFirstChild("HumanoidRootPart") then
			local kHRP = killer.HumanoidRootPart

            if attackType == "Legit" then
                local dist = (kHRP.Position - hrp.Position).Magnitude
                local r = tonumber(range) or 4
                if dist <= r then
                    if matchFacing then
                        hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + kHRP.CFrame.LookVector)
                    end
                    if mode == "Behind" then
                        local directionToTarget = (kHRP.Position - hrp.Position).Unit
                        local dot = hrp.CFrame.LookVector:Dot(directionToTarget)
                        if dot > 0.6 then return end
                    end
                    daggerRemote:FireServer("UseActorAbility", { buffer.fromstring("\"Dagger\"") })
                end
                return
            end

            if attackType == "Counter" and not killerPlayingCounterAnim(killer) then
            	continue
            end

			if isBehindTarget(hrp, kHRP) and killer ~= lastTarget then
				cooldown = true
				lastTarget = killer

				local start = tick()
				local didDagger = false
				local connection
				connection = RunService.Heartbeat:Connect(function()
					if not (char and char.Parent and kHRP and kHRP.Parent) then
						if connection then connection:Disconnect() end
						return
					end

					local elapsed = tick() - start
					if elapsed >= 0.5 then
						if connection then connection:Disconnect() end
						return
					end

					-- Prediction
					local pingMs = 50
					if pingItem and typeof(pingItem.GetValueString) == "function" then
						pingMs = tonumber((pingItem:GetValueString() or ""):match("%d+")) or pingMs
					end
					local pingSeconds = pingMs / 1000

					local killerVelocity = kHRP.Velocity
					local moveDir = killerVelocity.Magnitude > 0.1 and killerVelocity.Unit or Vector3.new()
					local pingOffset = moveDir * (pingSeconds * killerVelocity.Magnitude)
					local predictedPos = kHRP.Position + pingOffset

					local targetPos
					if mode == "Behind" then
						targetPos = predictedPos - (kHRP.CFrame.LookVector * 0.3)
					else
						local rightVec = kHRP.CFrame.RightVector
						local rel = (hrp.Position - kHRP.Position)
						local lateralSpeed = killerVelocity:Dot(rightVec)
						local baseOffset = (rel.Magnitude > 0.1) and rel.Unit * 0.3 or Vector3.new()
						local lateralOffset = rightVec * lateralSpeed * 0.3
						targetPos = predictedPos + baseOffset + lateralOffset
					end

					hrp.CFrame = CFrame.new(targetPos, targetPos + kHRP.CFrame.LookVector)

					if not didDagger then
						didDagger = true
						daggerRemote:FireServer("UseActorAbility", { buffer.fromstring("\"Dagger\"") })
					end
				end)

				task.delay(2, function()
					RunService.Heartbeat:Wait()
					while kHRP and kHRP.Parent and isBehindTarget(hrp, kHRP) do
						RunService.Heartbeat:Wait()
					end
					lastTarget = nil
					cooldown = false
				end)
				
				break
			end
		end
	end
end)

local Tab = Window:Tab({
    Title = "Hitbox ExpAnder",
    Icon = "bird", -- optional
    Locked = false,
})
